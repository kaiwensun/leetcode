# Formal proof of correctness

> Source: [540535](https://leetcode.com/problems/maximum-performance-of-a-team/discuss/540535/formal-proof-of-correctness)
>
> Created at: 2020-03-15 18:14:23
>
> Updated at: 2020-03-15 23:41:26

----

A python code is at the end. Let\'s prove the correctness of the algorithm implemented by the Python code. The algorithm is same as those presented in most other discussion posts.

# **Proof of Correctness**
---
Let\'s use `S` to name the solution (i.e. the set of hired engineers) found by the algorithm. For contraditory purpose *[note 1]*, suppose `S` doesn\'t have the best performance and there is another solution `S\'` which has a better performance than `S`. We are going to prove that such a `S\'` doesn\'t exist.

For the engineers in `S\'`, sort them by `data\' = sorted(zip(efficiency, speed), reverse=True)` *[note 2]*. In the alrogithm generating `S`, since we sort all engineers in the same way, (`data = sorted(zip(efficiency, speed), reverse=True)` ), there must be some point where the `eff` and `spd` in the code below being the last engineer in `data\'`, and all engineers in `data\'` were previously pushed into the priority queue `speed_heap`. At this point, since the efficiencies are same *[note 3]*, **we only need to compare the sum of speeds.**

`speed_heap` maintains the at most `k` biggest speeds so far. Since all  `data\'` engineers\' speeds were pushed into `speed_heap` previously, it is impossible that the sum of `data\'` engineers\' speeds is strictly greater than the sum of the at most `k` speeds in `speed_heap`.
Since in the algorithm we calculate `performance = max(performance, total_speed * eff)` (see code below), the final `performance` must be equal or greater than the `data\'` engineers\' performance. So it is false that `S\'` is strictly better than `S`.

So it is impossible to have a `S\'` strictly better than `S`.

So `S` generated by the algorithm is the optimal solution.


# **Notes**
---
[1] Proof by contradiction is the most common strategy to prove the correctness of greedy algorithms.
[2] I.e. sort in the decreasing order of their efficiency (if equal, sort by speed), for engineers in only `S\'`.
[3] The current `eff` and the efficiency of the last engineer in `data\'` are equal.

# **Python Code**
---
```
import heapq
class Solution(object):
    def maxPerformance(self, n, speed, efficiency, k):
        data = sorted(zip(efficiency, speed), reverse=True)
        speed_heap = []
        total_speed = 0
        performance = 0
        for eff, spd in data:
            heapq.heappush(speed_heap, spd)
            total_speed += spd
            if len(speed_heap) > k:
                total_speed -= heapq.heappop(speed_heap)
            performance = max(performance, total_speed * eff)
        return performance % (10 ** 9 + 7)
```